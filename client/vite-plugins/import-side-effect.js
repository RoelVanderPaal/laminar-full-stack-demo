import {splitModuleId} from "./helpers";
import MagicString from "magic-string";

/**
 * This plugin lets you import JS files or resources like CSS for their
 * side effects only, that is, ignore the imported value:
 *
 * `import "stylesheet.css"`
 *
 * To get this code, call JsImportSideEffect("stylesheet.css") in your code.
 * You need the JsImportSideEffect.scala interface file, and the JSGlobal
 * name in that file must match the `importFnName` option passed to this plugin.
 *
 * This is needed for Vite to process CSS imports from Scala.js files properly â€“
 * without warnings, and without double-loading the CSS.
 *
 * Scala.js itself does something like `import * as unused from "stylesheet.css"`,
 * which is technically equivalent to `import "stylesheet.css"`, but Vite treats
 * it differently, throwing a "Default and named imports from CSS files are deprecated"
 * warning.
 *
 * This plugin works in the following manner:
 * - JsImportSideEffect("stylesheet.css") emits `importFnName("stylesheet.css")` JS code
 * - This plugin finds all instances of `importFnName("bar")` in your JS files, comments them
 *   out, and inserts `import "bar";` statements at the top of the file.
 * - Therefore, the `importFnName` name must be a unique string in your codebase,
 *   and the `importFnName` option that you provide to this plugin must match the
 *   JSGlobal name of JsImportSideEffect.
 *
 * See:
 * - https://discord.com/channels/632150470000902164/635668814956068864/1161984220814643241
 * - https://vitejs.dev/guide/features.html#disabling-css-injection-into-the-page
 * - https://github.com/vitejs/vite/pull/10762
 * - https://github.com/vitejs/vite/issues/3246
 * - https://github.com/scala-js/scala-js/issues/4156
 */
export default function importSideEffectPlugin (options) {
  if (!options || !options.importFnName) {
    throw new Error("Regex replacer vite plugin: please provide options object with `importFnName` key")
  }
  if (!options.sourceMapOptions) {
    // See https://github.com/rich-harris/magic-string#sgeneratemap-options-
    options.sourceMapOptions = {};
  }
  if (options.sourceMapOptions.hires === undefined) {
    options.sourceMapOptions.hires = true; // high resolution source maps by default
  }
  return {
    name: 'import-side-effect',
    transform (code, id) {
      const {moduleId, querySuffix} = splitModuleId(id);

      // #TODO We only want to process JS files generated by scala.js,
      //  processing any other files is a waste of CPU cycles.
      if (moduleId.endsWith(".js") && !moduleId.includes("node_modules")) {
        // console.log(`>> import-side-effect processing module ${id}...`)
        const str = new MagicString(code);
        const pattern = new RegExp(`${options.importFnName}\\("([^"]+)"\\)`, 'g');
        const sideEffectImports = []

        let match = null;
        while ((match = pattern.exec(code)) !== null) {
          // console.log(">>    replacing!")
          sideEffectImports.push(match[1])
          str.appendLeft(match.index, "// ") // comment out the invocation of our non-existent function.
        }

        if (sideEffectImports.length > 0) {

          // Kind of fragile, because I don't really know what the modules can possibly look like in all cases.
          let insertAtIndex = 0
          if (code.startsWith("'use strict';\n")) {
            insertAtIndex = code.indexOf("\n") // second line
          }

          const importStatements = [
            "// -- Begin imports via import-side-effect --"
          ]
          sideEffectImports.forEach(importModuleName => {
            importStatements.push(`import "${importModuleName}";`)
          })
          importStatements.push(
            "// -- End imports via import-side-effect --"
          )

          // Imports must be at the top level in the module.
          // Note: We're inserting these side effecting imports before any other imports inserted by Scala.js.
          str.appendLeft(insertAtIndex, importStatements.join("\n"))

          return {
            code: str.toString(),
            map: str.generateMap(options.sourceMapOptions)
          };
        } else {
          return null;
        }
      }
    }
  };
}
